
  ======   NEXT14 FULL COURSE =======
TIME: 1:52:38s

1. Next.js is an open-source javascript framework that is build on 
to of react.
is a populary js library for building  user interfaces. 
It is designed to make it eaiser to create SERVER-RENDERED react application 
with a focus on 
- developer productivity
- performance
- SEO(search engine optimization)
next.js provides set of tools and conventions that simplify 
various aspects of building web applications.

FEATURES
- SERVER-SIDE RENDERING(SSR) ->next.js allows you to render react components 
on the server side before sending them to the client.  
(this improve page load and SEO, as engines can easily index content) 

- STATIC SITE GENERATION(SSG) -> you can pre-render pages
at build time. 
(this approach is great for content heavy websites and  can  offer 
even better performance and SEO benefits)

- API ROUTES -> it offers a build-in api route features that allows 
you to create a serverless api endpoint within your nextjs project, 
making it easy to handle backend logics. 

- FULL STACK FRAMEWORK -> have SERVER COMPONENT and 
CLIENT COMPONENT. 
=> (page.js)
-> you can the components name of the (page.js) 
-  we change the Page to Home
=> public folder 
- (is where we store our image and svg)
- you can also delete then when not in uses

=> (.eslintrc.json) 
- is an eslint file and you can delete  it if you wish
=> (postcss.config.js)
- for tailwindcss 
Do not delete cause it prompts error


2. ROUTING? 

Routing is like giving directions to a website. 
when you type a web address (url) int your browser, routing tells 
the wrbsites which page or thing to show you. It's like a map that 
guides the websites to the right place when you click a link or 
enter a web address. So, routing helps the website know that to 
display based on what you are lookng for.


=> basic routing 
- about folder must have page.js file 

=> Nested routing



3. Link 
time 27:47

- Link is a component provided by next.js that allows you 
create links to naviage between pages in your application 

- It is primary used for declarative, CLIENT-SIDE NAVIGATION. 
When you click on a link created with Link,  it prevents the 
default browser full-page refresh and fetches the new page 
content on the client side, resulting in a faster and smoother user  
experience. 

- It is typically used in your components jsx code to create clickable 
links that lead to other pages within your nextjs application


-> best practices is always to creat a client-side components 
outside the app directory. 
e.g creating components folders in the main file directory

example 
import { Inter } from "next/font/google";
import "./globals.css";
import Navbar from "@/components/Navbar";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Navbar />
        {children}
      </body>
    </html>
  );
}

4. useRouter()

- useRouter is a hook provided by nextjs that allows you to access the router 
object and its properties withing your component 

- It provides programmatic control over the router and 
allows you to navigate to different pags or perform other 
routing-related actions in response to user interactions or 
events within your component. 

- It is useful when you need to handle navigation or access route-specific 
information directly in your component logic.
===> it gives control over our navigatio

example 

"use client";
import { useRouter } from "next/navigation";
const page = () => {
  const router = useRouter();
  return (
    <section>
      <h1>useRouter</h1>
      <button onClick={() => router.push("about")}>Go to about page</button>
    </section>
  );
};

export default page;

example (this is another way of use useRoute)

"use client";
import { useRouter } from "next/navigation";
const Home = () => {
  const router = useRouter();
  const navigate = (page) => {
    router.push(page);
  };
  return (
    <section>
      <h1>useRouter</h1>
      <button onClick={() => navigate("about")}>Go to the about Page</button>
      <button onClick={() => navigate("login")}>Go to the Login page</button>
    </section>
  );
};

export default Home;


==> (auth) 
WHAT DO WE MEAN BY ?..

5 . Dynamic Routes 
time -> 46:00

- Dynamic routes in Next.js refer to a feature that allows you 
to create web pages with variable or dynamic parts in the  URL. 
Instead of defining individual routes for every possible URL, 
you can create a single route pattern that matches a variety of 
dynamic values. This is extremly useful when you have pages 
that share a common structure but differ based on specific  
information in the url. 


- (auth) -> the bracket around it shows we are ignoring this file 
to be a route.

example 

"use client";
const User = ({ params }) => {
  console.log(params);
  return <div>User</div>;
};

export default User;


example 

"use client";
const User = ({ params }) => {
  return (
    <div>
      <h1>Info About {params.user}</h1>
      <p>Hello I'm {params.user}</p>
    </div>
  );
};

export default User;


  


  6.  CATCH-ALL ROUTES 
  TIME: 52:45 

  - In next.js the [...foldername] notation indicates that you 
  are using a catch-all routes, which allows you to capture multiple 
  URL segments and treat them as a dynamic array of values. 
  This is useful when you want to create dynamic routes that 
  can handle varying numbers of URL segments

  e.g [...allroutes]

   - [...all] => this is a special syntax used to denote  
   catch-all routes. When you create a folder with this name withing the 
   pages directory, Next.js recognizes it as a dynamic route that  
   matches any route under its parent routes.

  example 

  "use client";
const Project = (params) => {
  console.log(params);
  return <div>this is all routes for project</div>;
};

export default Project;


  example 
"use client";
const Project = ({ params }) => {
  return (
    <div>
      <h1>Project {params.all}</h1>
      <br />
      all Routes
      {params.all.map((p) => (
        <li key={p}>{p}</li>
      ))}
    </div>
  );
};

export default Project;


nb--> In most case we are not going to be using this catch all routes


==> CREATING A 404 PAGE 
- go to app directory and create a file called 
not-found.js. 
- this file is going to represent your defualt 404. 

exmaple (with a file name   not-found.js) 
you can use tsx,ts,jsx

import React from "react";

const NotFound = () => {
  return (
    <div>
      <h1>This page does not exist</h1>
    </div>
  );
};

export default NotFound;


 7. REDIRECT IN NEXTJS 
 TIME: 1:00:46
 
 The redirect function allows you to redirect the user 
 to another URL. redirectt can be used  
 Server components, client components, Route handlers, 
 Server actions. 
  
 -  when used in a streaming context, this will insert a meta tag 
 to emit the redirect on the client side. Otherwise,  it will 
 serve a 307 HTTP redirect response to the caller. 

 -If a resources does n
 ot exist, you can use the 
 notFound function instead. 

 -If you prefer to return a 308(permanent) HTTP redirect 
 instead of 307(Temporarily) you can use the 
 peramanentRedirect function instead.

 PARAMETERS FOR REDIRECT FUNCTION 
- The redirect function accepts two arguments 
redirect(path, type)

example  

import { redirect } from "next/navigation";
const ID = ({ params }) => {
  if (params.id == 4) {
    redirect("/login");
  }
  return <div>{params.id}</div>;
};

export default ID;

--> once you click on localhost:3000/about/4 
it will redirect you back to /login 
==> this techniques is used to block an id from viewing 
a site.


8. SERVER COMPONENTS 
time: 1:04:50 

- React Server components allow you to write UI that can be 
rendered and optionally catched on the server. In Next.js, 
the rendering work is further split by route segments to  
enable streaming and partial rendering, and there are 
three different server rendering strategies 
- STATIC RENDERING 
- DYNAMIC RENDERING
- STREAMING  

BENEFIT OF SERVER RENDERING
- Data fetching 
- security 
- Caching 
- Bundle sizes 
- Inital page reload
-  search engine optimization  
-  streaming.

By defualt next.js uses server components. This allows yo to 
automatically implement server rendering with no additional configuration.


9. CLIENT COMPONENTS 
time: 1:06:48 

client components allows you to write interactive UI that can be 
rendered on the client at request time. In next.js, client 
rendering is opt-in,  meaining you have to explicitly decide 
what components React should render on the client. 

benefits of Client Rendering 
- Interactivity: client components use use  
state, effects, and event listeners, meaining they can provide 
immediate feedback to user and update the UI. 

- Browser APIs: client components have access to browsers ApIs, 
lie geolocation or localStorage, allowing you to build UI for  
specific use cases. 

WHEN TO USE SERVER COMPONENTS 
- access backend resources (directly)
- keep sensitive information on the sever 
(access token, api keys etc) 
- keep large dependencies on the server/ Reduce client-side 
javascript. 
WHEN TO USE CLIENT SIDE 
- add Interactivity and event listeners 
(onclick(),  onchange())
- use state and lifecycle effects
(useState(), useReducer(), useEffect(), etc)
- use Browser-only APIs- use custom hooks that depend on the 
state, effect or browser-only APIs 
- use react class components

example of client components 

"use client";
const ClientOne = () => {
  console.log("hello from (client component)");
  return <div>ClientOne</div>;
};

export default ClientOne;


--> A client component is basically 
a client and a server components. 
- the console.log returns two response 


10 LAYOUT? 

- A Layout is like a blue print that helps you make all the 
pages of your website look thesame. It is a way to put common 
things, header, footer, and other stuff that appears on every page, 
in one place. this makes it easy to keep a similar look on all 
yur web pages. So, a layout is a handy tool that lets you keep 
things tiey and consistent on your websites. 


example 
import { Inter } from "next/font/google";
import "./globals.css";
import Navbar from "@/components/navbar";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Navbar />
        {children}
      </body>
    </html>
  );
}

HOW TO IMPORT TEXT ON NEXTJS 

example

"use client";
import { Roboto } from "next/font/google";
const roboto = Roboto({ subsets: ["latin"], weight: "500" });

const page = () => {
  return (
    <div>
      <h1>Google Fonts</h1>
      <h2 className={roboto.className}>Hello this is robot font</h2>
    </div>
  );
};

export default page;

11 FETCHIG DATA USING CLIENT COMPONENTS 
time: 1:42:44 

====> jsonplaceholder 
Free api post => "https://jsonplaceholder.typicode.com/posts"

exmaple of fetching data from api 

"use client";
import { useEffect, useState } from "react";
const Data = () => {
  const [product, setProduct] = useState([]);

  useEffect(() => {
    async function fetchData() {
      let data = await fetch("https://jsonplaceholder.typicode.com/posts");
      data = await data.json();
      console.log(data);
    }
    fetchData();
  }, []);
  return <div>Data</div>;
};

export default Data;


exmaple of returning the fetched data  


"use client";
import { useEffect, useState } from "react";
const Data = () => {
  const [product, setProduct] = useState([]);

  useEffect(() => {
    async function fetchData() {
      let data = await fetch("https://jsonplaceholder.typicode.com/posts");
      data = await data.json();
      setProduct(data);
    }
    fetchData();
  }, []);
  return (
    <ul>
      {product?.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
};

export default Data;


another example  


"use client";
import { useEffect, useState } from "react";
const Data = () => {
  const [product, setProduct] = useState([]);

  useEffect(() => {
    async function fetchData() {
      let data = await fetch("https://jsonplaceholder.typicode.com/posts");
      data = await data.json();
      setProduct(data);
    }
    fetchData();
  }, []);
  return (
    <ul>
      {product?.map((p) => (
        <li className="border m-5 py-2 px-4" key={p.id}>
          {p.title}
        </li>
      ))}
    </ul>
  );
};

export default Data;


12 FETCHIN DATA USING SERVER COMPONENTS 
time: 1:47:37

-> it must be an asynchronous programming 

example of server data fetching 

async function fetchData() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts");
  data = await data.json();
  return data;
}

const Data = async () => {
  let products = await fetchData();
  console.log(products);
  return (
    <div>
      {products?.map((p) => (
        <p key={p.id}>{p.title}</p>
      ))}
    </div>
  );
};

export default Data;


- when fetching data using the server components.  you see 
result only on the node run time (the terminal of the vscode) 
not the console of the browser . This is because is  a  server 
components





===== NPM INSTALLATION ====
 - npx creat-next-app@latest . 
 [it creates it in the current directory]
 - npm run build 
 (creates  .next  -> which can be deleted without breaking the code)

